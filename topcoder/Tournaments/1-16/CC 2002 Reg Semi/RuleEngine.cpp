#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <regex>
#include <unordered_map>

using namespace std;

typedef long long ll;
ll toInt(string s) {stringstream in(s, ios_base::in); ll result; in >> result; return result;}

string toString(ll n) {stringstream out(ios_base::out); out << n; return out.str();}

string toString(int n) {return toString((ll)(n));}


bool test_condition(string condition, int lhs, int rhs, int rhs1)
{
    if (condition == "==")
        return lhs == rhs;
    else if (condition == "<")
        return lhs < rhs;
    else if (condition == "<=")
        return lhs <= rhs;
    else if (condition == ">")
        return lhs > rhs;
    else if (condition == ">=")
        return lhs >= rhs;
    else if (condition == "!=")
        return lhs != rhs;
    else if (condition == "<>")
        return (lhs >= rhs && lhs <= rhs1);

    return false;
}

class condition
{
public:
    char symbol;
    string bool_condition;
    int value1;
    int value2;

    virtual vector<int> testComparison() 
    {
        vector<int> possibleVals;

        for (int i = -10; i <= 10; ++i)
        {
            if (test_condition(bool_condition, i, value1, value2))
                possibleVals.push_back(i);
        }

        return possibleVals;
    }
};

condition matchCondition(string str)
{
    cmatch res;
    // regex rx1("(\\w)([><=!][=?])(-?[0-9])");
    regex rx1("(\\w)([><=!]=?)(-?\\d{1,2})");
    regex rx2("(\\w)B(-?\\d{1,2}),(-?\\d{1,2})");
    bool res2 = regex_match(str.c_str(), res, rx2);

    condition c;
    if (res2)
    {
        c.symbol = *(string(res[1]).c_str());
        c.bool_condition = "<>";
        c.value1 = (int)toInt(res[2]);
        c.value2 = (int)toInt(res[3]);

        return c;
    }

    if (!res2)
    {
        bool res1 = regex_match(str.c_str(), res, rx1);
        c.symbol = *(std::string(res[1]).c_str());
        c.bool_condition = res[2];
        c.value1 = (int)toInt(res[3]);
        c.value2 = -1;
    }

    return c;
}

struct RuleSet
{
    vector<condition> rules;
};


class RuleEngine 
{
    vector<vector<vector<int> > > myvec;

    int get_intersection(int symbol_index)
    {
        vector<int> results(21);
        vector<int>::iterator it;
        vector<int> first;

        first = myvec[symbol_index][0];

        if (myvec[symbol_index].size() == 1)
        {
            results = first;
            return results.size();
        }


        for (int i = 1; i < myvec[symbol_index].size(); i++)
        {
            vector<int> newOne = myvec[symbol_index][i];
            it = set_intersection(first.begin(), first.end(), newOne.begin(), newOne.end(), results.begin());
            first.clear();
            first.resize(it - results.begin());
            copy(results.begin(), it, first.begin());
        }

        return it - results.begin();
    }

public:
	string countSets(vector <string> param0, vector <string> param1) 
    {
        myvec.resize(26);

        int numValues = 1;

        for (int i = 0; i < param0.size(); ++i)
        {
            condition c = matchCondition(param0[i]);
            vector<int> values = c.testComparison();
            int symbol_index = (int)(c.symbol - 'A');

            if (values.size() != 0)
                myvec[symbol_index].push_back(values);
        }

        for (int i = 0; i < param1.size(); ++i)
        {
            condition c = matchCondition(param1[i]);
            vector<int> values = c.testComparison();
            int symbol_index = (int)(c.symbol - 'A');

            if (values.size() != 0)
                myvec[symbol_index].push_back(values);
        }

        for (int i = 0; i < 26; ++i)
        {
            // Iterate through all symbols found.
            if (myvec[i].size() == 0)
                continue;

            int numVals = get_intersection(i);
            numValues *= numVals;
        }

        return toString(numValues);
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <string> p0, vector <string> p1, bool hasAnswer, string p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p1[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	RuleEngine *obj;
	string answer;
	obj = new RuleEngine();
	clock_t startTime = clock();
	answer = obj->countSets(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p2 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <string> p1;
	string p2;

    // { "A<01", "B==2", "C>4", "D>=2", "E<=9", "FB1,2", "J!=6" }, { "A<9", "B>=2" } - 475200
    string ruleset1[] = { "A==1", "X>=4", "F<1" };
    string ruleset2[] = { "X>=5", "ZB2,9" };

    p0.assign(ruleset1, ruleset1 + 3);
    p1.assign(ruleset2, ruleset2 + 2);

    RuleEngine re;
    p2 = re.countSets(p0, p1);
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
